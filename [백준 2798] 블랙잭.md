브루트포스 알고리즘에 관한 문제다.

사실 브루트포스라는 말을 처음 들어서 문제를 풀기 전 살짝 쫄았던 탓인지 머리가 잘 돌아가지 않았다. 이전 하노이탑의 후유증이 가시지 않았는지 엄청 꼬아서 생각했는데 문제는 단순했다. 입력한 카드 중 3장의 카드는 뽑아 한도를 넘지 않는 가장 큰 값을 출력하는 것이다. 

일단 브루트포스(bruteforce)란 '무식한 힘'이라는 뜻인데, 정말 무식하게 모든 경우의 수를 탐색하는 알고리즘이다. 그래서 시간초과의 부담없이 중첩 반복문을 사용하여 풀어봤다. 입출력이 올바르게 작동하여 기분 좋게 제출했다.

하지만 결과는 '틀렸습니다'

도대체 왜..?

(내 코드)
```
N,M=map(int,input().split()) #카드 장수, 한도
C=list(map(int,input().split()))
mx=[] #합이 21보다 작거나 같은 수를 넣을 리스트

for i in C:
  for j in C[C.index(i)+1:]:
    for k in C[C.index(i)+2:]:
      if i+j+k <=M:
        mx.append(i+j+k)
        
print(max(mx))
```

일단 인정하고 다른 풀이를 찾아보았다. 

전체적은 구조는 맞는 것 같다. 다만, 다른 풀이들과 다른점은
1. 반복범위 - 그냥 range로 돌림
2. if문 - result=max(result, sum)식을 사용

범인은 1번이었다.

k가 돌아가는 for문의 범위!

게시판에 물어본 결과, 입력 3 11 / 1 2 5 일 때가 반례라고 한다. 입력을 해보니 8이 아닌 11이 나왔다. 어떻게 이럴 수 있는지 mx를 함께 출력해보니 mx에 11이 들어있었다.

![](https://images.velog.io/images/alswjd_0813/post/0a078957-32a4-4349-b321-2dddf9a0bef4/image.png)

왜 그런 것일까.

혹시나 하고 k의 반복범위를 C[C.index(j)+1]로 바꾸니까 맞았다고 떴다. 머릿속으로는 '아 이게 맞지' 싶지만 직접 값을 돌려가면서 생각해보니 왜 틀린 지 정확하게 알 수 없었다.

다시 게시판으로 가서 질문을 달았다.

답변을 보니..범위를 index()를 사용하는 방식 자체가 잘못되었다고 한다.

하나씩 짚어보자.

> # k의 범위 C[C.index [ i ]+2: ]과 C[C.index[ j ]+1: ]의 차이

일단 입력은 3 11 / 1 2 5를 가정한다.

첫번째 방법은 i를 기준으로 k가 탐색범위를 정하기 때문에 i가 1을 먼저 뽑으면 j는 [2,5] 중에 2를 뽑는다. 이후 k는 [5] 중에 5를 뽑는다. k루프를 나온 후 j는 [2,5] 중에 5를 뽑고 k는 여전히 [5]를 가지고 있어 이것을 다시 뽑는다. 

여기서 문제가 발생한 것이다.  
계획대로라면 j가 마지막요소인 5를 뽑으면 k는 더 이상 뽑을 게 없어 그냥 루프는 나와야 하지만 i를 기준으로 탐색하기 때문에 i가 변하지 않아 여전히 [5]를 가지고 있었던 것이다. 

따라서 C[C.index [ i ]+2: ]가 아니라 C[C.index[ j ]+1: ]로 작성해야 j가 [2,5]에서 5를 뽑은 후 k는 j의 다음 요소가 없으므로 루프를 종료하게 된다.

하지만, 이렇게 index()로 범위를 결정하는 것 자체가 문제가 있다.


> # 범위를 index()를 사용하여 정하면 안되는 이유

이 문제에서 카드의 중복에 대한 얘기가 없어서 고려하지 못했는데, '카드가 중복되지 않는다'는 말이 없으므로 중복도 고려하는 것이 많는 것 같기도 하다.

반례는 여기서 나타난다.

입력을 3 12 / 4 4 1로 가정하면
첫 루프에서 i가 [4,4,1] 중 4를 뽑고 j가 [4,1]중에서 4를 뽑고, k가 1을 뽑는다. 이후 j가 다시 [4,1] 중에서 1을 뽑고 k는 바로 종료된다. 두 번째 루프에서 i가 [4,4,1] 중 두번째 4를 뽑는다. 그러면 j는 [1] 중에서 1을 뽑아야 한다.

하지만 예상과는 다르게 j는 다시 [4,1]에서 뽑게 된다. 
이유인즉슨 index()는 같은 값이 여러개 있는 경우 항상 첫번째 인덱스를 반환하기 때문이다.

카드의 중복을 고려하지 못했던 이유도 있지만, index()를 사용하면서 '이건 해당 요소가 여러 개 있을 경우 무조건 처음으로 발견되는 요소의 인덱스를 반환하지!'라는 것을 인지하고 사용했던 것은 아니었다.

앞으로 함수를 사용할 때는 반환되는 값의 특성을 잘 알고 쓰도록 하자.

어쨌든 나의 궁금증이 모두 풀렸다~~

답변해주신 분께 감사를 드리며 노트정리 끝...



