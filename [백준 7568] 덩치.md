사람의 키와 몸무게를 입력하면 키와 몸무게에 따라 덩치 순위를 출력하는 문제이다.

덩치를 비교하는 기준은 사람A와 B를 예를 들면, A의 키와 몸무게 둘다 B보다 큰 경우 A의 덩치가 B보다 크다고 판단한다. 하지만 A의 키가 B보다 크지만 몸무게는 B가 더 나가는 경우 비교할 수 없으므로 같은 순위가 된다.

이 역시 브루트포스 문제이기에 전수조사를 하면 되겠다 싶어서 호기롭게 시작했다. 

일단 몸무게와 키의 리스트를 따로 만들어서 몸무게의 최댓값을 찾은 다음 키를 전수조사하여 가장 큰 것과 같으면 1등! 아니면...

아니면...

막혀버렸다..

아 그럼 몸무게가 최대인 사람의 키보다 큰 사람을 찾자!
만약에 없으면 1등! 이건 확실히 1등이니까 리스트에서 지우고 다시 돌리면 되겠다! 만약 더 큰 사람이 있다면 이 둘은 순위가 같네~

하지만 틀렸다.

같은 순위라 사람이 여러명이 될 수 있는데, 이런 방식으로 하면 같은 순위의 사람을 제대로 매길 수 없었다.

리스트 정렬을 해볼까? (삽질이었음)

아무리 생각해봐도 적절한 알고리즘을 생각해내지 못했다

일단 어려웠던 점은

1. 순위를 매길 수 없는 사람들에 대한 비교
-> 아무리 전수조사라도 결국은 둘씩 비교하는데 순위가 같은 여러명은 어떻게 비교할 수 있을까

2. 만약 같은 순위의 사람들을 추렸다고 하자. 그럼 그 다음 순위를 계산하는 방법은?

이리하여 결국 해답을 보기로 했다. 

해답을 보자마자 내가 간과하고 있었던 것이 있었다는 걸 알게되었다. 리스트에 튜플 형태로 넣을 수 있다는 것!!!!

키와 몸무게를 쌍으로 어떻게 안되나?까지는 생각했는데 튜플을 안다뤄봐서 그런지 떠오르지 않았다..

일단 코드는 아래와 같다.
```
N=int(input()) #사람 수
st=[]

for i in range(N):
    w,h=map(int, input().split())
    st.append((w,h)) #리스트에 쌍으로 추가

for i in st: #전체 중 하나를 뽑음
    r=1 #등수, 1등부터 시작
    for j in st: #하나와 전수 비교 (j 범위 조심)
        if i[0] < j[0] and i[1] < j[1]: #작으면
            r+=1 #순위 밀려남
    print(r,end=' ')
```
처음 코드를 봤을 때 한 가지 걸리는 점이 있었다. j의 반복범위.

그 놈의 범위..

아주 죽겠다 진짜

이게 왜 눈에 들어왔냐면, j 다음에 i[0], j[0], i[1], j[1]를 print해봤더니 처음에 자기 자신과 비교를 했다.

그래서 j의 범위가 st[:1] 여도 되지 않나?해서 시도해보니
순위가 잘 나오지 않았다.

그 이유는 바로 i가 다음 튜플로 넘어가도 j는 처음부터 비교를 해야하기 때문에 i에 상관없이 st를 모두 범위로 갖는다.

이번 문제의 **핵심적인 아이디어**는 순위가 작으면 순위가 밀려나는 방식이다. 생각도 못했다...

덩치가 작은 것이라고 판단되면 순위를 하나씩 깎아서 순위를 매기는 것이다.

여기서 난 또 생각을 했다.

아니, 순위가 N(꼴찌)에서 점점 올라갈 수도 있는 거 아닌가???

그리하여 r=N, if문의 부등호 방향, r-=1 을 바꾸고 예제 입력을 해보았다

결과는 4 4 1 4 5 가 나왔다.

원래대로라면 2 2 1 2 5 가 나와야 한다.

출력을 보고 이유를 알게 되었다.

어려웠던 점 2번에 관련된 내용일 수도 있는데, 문제에서 등수는 '자신보다 더 큰 사람 수+1'이라고 제시되었다. 따라서 1등부터 시작해서 자신보다 더 큰 사람이 있으면(if문) 순위가 내려가도록 계산하는 것이 맞는 것이다. 

잘못된 출력의 경우, N에서 점차 등수를 올려버리면 이전 등수보다 하나 올라가는 것이므로 5등보다 하나 위인 4가 나왔다고 볼 수 있다.

오늘 알게된 점을 정리해보자면, 

> "리스트에 튜플형태로 넣을 수 있으며, i[0], j[1]의 방식으로 반복문에서 튜플의 요소에 접근할 수 있다."




참고:[https://claude-u.tistory.com/122](https://claude-u.tistory.com/122)
