# [백준 1541] 잃어버린 괄호 

### 문제

세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다.

그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다.

괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오.

**입력**

첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘+’, 그리고 ‘-’만으로 이루어져 있고, 가장 처음과 마지막 문자는 숫자이다. 그리고 연속해서 두 개 이상의 연산자가 나타나지 않고, 5자리보다 많이 연속되는 숫자는 없다. 수는 0으로 시작할 수 있다. 입력으로 주어지는 식의 길이는 50보다 작거나 같다.

**출력**

첫째 줄에 정답을 출력한다.

</br>

### 문제해결과정

어떻게 하면 최솟값을 만들 수 있을까 생각해보다가 음수를 크게 만들면 되겠다는 생각을 했다. 

+를 우선적으로 계산하면 된다. 

입력이 문자열로 들어오기 때문에 숫자를 추출하는 것이 관건이다.

부호와 숫자를 서로 다른 배열에 담아 인덱싱을 해서 풀어나갈 수 있었다.

첫 번째와 마지막 문자는 무조건 숫자이므로 첫번째 숫자는 양수이다. 따라서 부호에는 '+'를 미리 하나 넣고 시작했다.

for문을 이용해서 부호와 숫자를 따로 담은 뒤, 숫자 배열은 계산을 위해 int형으로 변환시켰다.

그리고 나서 덧셈으로 이루어진 값들은 서로 더해주고 뺄셈이 나오면 지금까지 누적한 값을 ans에 따로 모았다. 

누적에 사용했던 변수 su에 ans[0]라는 첫번째 숫자를 부여하고 두번째 원소부터 su에 뺄셈을 진행하여 값을 출력했다.

```python
N = input()
bh = ['+'] #부호
num = []
su = 0
ans = []
for i in N:
    if i== '+' or i=='-':
        bh.append(i)
        N = N.replace(i,' ')
        
num = list(map(int,N.split(' ')))

for i in range(len(num)):
    if bh[i] == '+':
        su += num[i]
    else:
        ans.append(su)
        su=num[i]

ans.append(su) 
su=ans[0]
for i in range(1,len(ans)):
    su -= ans[i]

print(su)
    
```

</br>

### 다른방법 및 코드개선

for문을 여러번 사용하는 게 조금 걸렸는데, 약간 다른 방식으로 생각해서 비슷하게 구현한 코드가 있었다. 아래 코드의 풀이를 보면,

처음에 -를 기준으로 먼저 분리하고 , ans에는 가장 먼저 나오는 +로 이루어진 값들의 합을 넣었다.

> 부호와 숫자 배열을 따로 저장하는 것보다 효율적
>
> ans는 첫번째 숫자가 아닌, 첫번째 +로 묶인 값들임!

li의 두번째 원소부터 split('+')을 해서 num_list에 넣고 동시에 map을 사용해서 int로 형변환까지 하였다.

ans에 num_list의 총합을 빼주어 값을 도출했다.

> +계산을 먼저 한 뒤 이 값을 매번 ans에서 빼주는 것이므로 split()과 연산을 같이 할 수 있음
>
> => for문을 줄일 수 있다.



```python
N = input()
li = list(N.split('-'))
ans = sum(map(int, li[0].split('+'))) # 가장 처음 나오는 +로 묶인 값들의 합
for i in range(1, len(li)): #li의 첫번째 리스트를 제외하고 계산해야함
    num_list = map(int, li[i].split('+')) #num_list : +로 묶여있는 숫자들
    ans -= sum(num_list)
print(ans)
```

덧셈을 먼저 계산하고 -가 나올 때마다 ans에서 빼주는 방식은 동일하지만, 이를 풀어가는 방식은 조금 달랐던 것 같다. 위 코드는 동시에 진행할 수 있는 부분은 한 번에 묶어서 계산했기 때문에 사용하는 변수도 적고, for문도 한 번만 사용하므로 훨씬 효율이 좋은 코드이다.

</br>

### 요약정리

이 문제와 같이 하나의 구간을 잘라서 그들의 합을 ans와 연산해주는 과정은 굳이 모든 배열을 만든 뒤 연산을 따로 할 필요 없이 그때그때 필요한 값이 생성되면 바로 연산을 할 수 있도록 해서 사용되는 반복문을 줄이는 연습을 해야할 것 같다.