# [백준 15649] N과 M(1)

### 문제

자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.

- 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열

**입력**

첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)

**출력**

한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.

수열은 사전 순으로 증가하는 순서로 출력해야 한다.

</br>

### 문제해결과정

중복되지 않도록 숫자를 뽑는다는 대목에서 순열임을 알 수 있다.
itertools의 함수를 사용해서 풀 수도 있었지만 함수를 이용하면 백트래킹을 구현하지 않고 넘어가는 것이기 때문에 직접 구현을 해보기로 했다. 하지만 적당한 알고리즘이 생각나지 않아 답을 찾아보았다.

</br>

대부분 DFS 함수를 만든 뒤 재귀함수를 사용했다.
처음 코드를 봤을 땐 동작과정이 이해되지 않았는데, print()를 중간중간 넣으면서 동작과정을 살펴보니 이해할 수 있었다.
특히 함수의 호출과 복귀를 잘 다루지 않다보니 재귀함수 호출 및 종료 후 원래 함수로 복귀한다는 점을 인지하지 못해 코드 이해가 더욱 오래 걸렸다.

</br>

전체적인 구조는 다음과 같다.

* 첫번째 if문에서 스택 길이가 뽑아야하는 수와 같다면 스택의 요소를 출력하고 함수를 종료한다.

* 만약 위 조건이 맞지 않는 경우 새로 뽑는다

* 우선 스택에 있는 수를 확인한 뒤 해당 숫자를 뽑았으면 다음 숫자로 넘어가서 확인한다(continue)

* 스택에 없는 숫자라면 스택에 push하고 함수를 호출한다. 

* 위 과정을 반복하다 호출된 함수가 종료되면, 함수 호출 지점으로 돌아와 pop을 하고 다음 숫자를 뽑아 반복문을 이어간다.

</br>

```python
n, m = map(int, input().split())

s = []
def f():
    if len(s) == m: #함수종료조건
        #뽑을 수만큼 뽑으면 출력
        print(' '.join(map(str, s)))
        return #현재 호출한 함수 종료 => 이전 함수로 복귀(pop부터 다시 진행)
    
    # 종료조건에 만족하지 않는 경우
    for i in range(1, n + 1):
        #이미 뽑은 숫자일 경우
        if i in s: 
            continue # 다음 숫자 뽑음(아래 코드 스킵)
        
        #다른 숫자를 뽑은 경우
        s.append(i) #스택에 추가
        f() # 함수 호출
        s.pop() #복귀 후 pop

        # i는 함수 호출 이전 값이 유지됨(이어서 뽑게 됨)
f() 
```

이러한 코드는 이론을 배울 때나 봤지 직접 구현해볼 기회가 없었다.
그래서 더욱 낯설게 느껴지는 것 같지만 연습하다보면 익숙해질거라  믿는다.

</br>

### 요약정리

* 백트래킹
    </br>
    **DFS**를 기반으로하여 모든 경우의 수를 탐색하는 브루트포스와 유사한 알고리즘이다. 단, 백트래킹은 **가지치기**를 통해 불필요한 반복을 줄인다.
* 재귀함수
    </br>
    재귀함수 사용 시 호출 함수의 **종료조건**을 꼭 설정해야하고, 코드 실행 중 함수 호출이 발생하면 현재 함수 실행을 중단하고 호출한 함수부터 실행한다. 이 함수가 종료되면 이전 함수가 중단된 위치로 **복귀**하여 남은 코드를 이어서 실행한다.