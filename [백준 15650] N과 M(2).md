# [백준 15650] N과 M(2)

### 문제

자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.

* 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열

* 고른 수열은 오름차순이어야 한다.

**입력**

첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)

**출력**

한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.

수열은 사전 순으로 증가하는 순서로 출력해야 한다.

</br>

### 문제해결과정

이전 문제와 연계되는 문제로, 뽑았을 때의 수열이 오름차순이어야 한다는 조건이 추가되었다.

처음에 for문안의 조건문은 해당 숫자를 뽑지 않는 경우이기 때문에 `i < s[-1]` 라는 조건을 추가해서 실행시켰더니 인덱스 오류가 났다.
이유인즉슨, 처음 s는 비어있기 때문에 마지막 원소가 존재할 수 없다. 따라서 s의 길이가 0일 때와 0이 아닐 때를 나누어서 작성했다.

</br>

스택이 비어있을 때는 뽑은 수는 무조건 저장한 뒤 재귀함수를 호출하고 스택이 비어있지 않을 때는 뽑은 수가 s에 있는지 혹은 s의 마지막 원소보다 작은지를 비교하여 둘 중 하나라도 포함되면 뽑으면 안되므로 continue 해주었다.

</br>

```python
n,m = map(int, input().split())
s=[]

def f():

    if len(s) == m:
        print(' '.join(map(str, s)))
        return

    for i in range(1,n+1):
        if len(s) == 0:
            s.append(i)
            f()
        else:
            # print('i',i,'s[-1]',s[-1])
            if i in s or i < s[-1]: #뽑지 않는 경우
                # print('continue')
                continue
            # print('append ',i)
            s.append(i)
            f()
        s.pop()

f()
```