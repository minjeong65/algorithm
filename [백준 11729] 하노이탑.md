이 문제를 가지고 낑낑댄지 이틀이 지나서야 해답을 보기로 했다. 이건 내가 분명 모르는 함수를 사용할 것이라 생각했기 때문이다.

![](https://images.velog.io/images/alswjd_0813/post/677513fd-0b1d-4cec-be3e-d5eb1769b5e7/%EA%B3%A0%EB%AF%BC.jpg)
(고민의 흔적들...)

발견했던 규칙
1. 마지막 원판을 제외한 나머지 원판들을 보조 기둥으로 옮긴 뒤, 마지막 원판을 목적지 기둥으로 보낸 후, 보조 기둥에 있는 원판들을 다시 목적지로 옮긴다.
2. 옮길 원판이 짝수면 보조 원판으로 먼저 옮기고, 홀수면 목적지 원판으로 먼저 옮긴다.

핵심적인 규칙들이라도 발견해서 내심 뿌듯했다. (아주 잠깐)


```python
def hanoi(n,a,b): #n:원판 개수, a:출발막대, b:도착막대
    if n>1:
    	hanoi(n-1,a,6-a-b) #6-a-b:보조막대(남는 막대)
    print(a,b)
    
    if n>1:
    	hanoi(n-1,6-a-b,b)
   
n= int(input())

print(2**n-1)
hanoi(n,1,3)
```
처음 코드를 마주한 순간 어떻게 이렇게 깔끔하게 나올 수 있나 놀랐고, 아무리 설명글을 읽고 해설 영상을 들어도 이해가 안 돼서 2차로 놀랐다. 뭔 소리야를 반복하다 넘어갈까하는 생각도 들었지만 차근차근 보기로 했다.

자, 나중에 까먹을 나를 위해 적어보겠다.

아래 첨부한 링크를 따라가면 상세하게 설명한 영상이 있다. 간략하게 설명하자면 예를 들어 3개의 원판을 옮긴다고 할 때 맨 밑에 있는 것을 제외한 모든 원판을 보조 막대로 옮긴 뒤, 마지막 원판을 도착막대로 옮기면, 이 마지막 원판은 고정이 된 것과 마찬가지다. 여기서 보조막대가 도착지가 되므로 hanoi(n-1,a,6-a-b)와 같은 코드가 사용되었다. 이후 보조 막대로 옮겼던 것을 그대로 도착지로 옮기면 된다. 이때 출발지가 출발막대에서 보조막대로 바뀌기 때문에 hanoi(n-1,6-a-b,b)와 같은 코드가 쓰였다.

N=3을 입력할 때를 살펴보면 함수는 hanoi(3,1,3)으로 시작한다.
첫번째 if문에서 걸리게 되어 N-1인 N=2의 함수를 재귀하면 도착지가 보조막대로 바뀌며, 또다시 if문에 걸린다. 
N=1함수를 재귀하면 다시 도착지가 보조가 아닌 원래 도착지가 되고, 이때는 if에 걸리지 않아 print(1,2)만 하게 된다.
이후 if문에 걸리느라 잠깐 중단되었던 N=2일 때의 함수가 재개된다. 
여기서는 출발지가 보조 막대로 바뀐다. 이것은 보조막대로 옮긴 원판을 이제 도착지로 옮겨야 하기 때문에 출발지가 바뀌었다. 
하지만 print(1,3)를 하고 다시 if에 걸린다. 여기서 N=1일 때 옮긴 원판을 목적지로 옮기기 위해서 출발지가 보조막대이다. 
if문을 제치고 print(2,3)을 끝내면, N=2에서와 같이 중단되었던 N=3일때 함수가 재개되어 print(1,3)을 하고 다시 if문에 걸리게 된다.
위와 같은 방법으로 계속 해 나가면 결국 N=1일 때의 함수를 재귀하여 기둥의 역할을 바꿔가며 하나의 원판을 계속 옮기는 꼴이 된다. 
![](https://images.velog.io/images/alswjd_0813/post/7248bac2-dd15-4e33-aa6c-37b77309165e/%EA%B7%B8%EB%A6%BC.jpg)
사실 누군가에게 완벽하게 설명할 정도로 이해한 것은 아니지만 계속 반복해서 보다보니 이해보다는 설득이 된 것 같다.

나는 세 개의 리스트를 만들어 append, remove를 가지고 그 안에서 실제로 옮겨다니도록 구현하려고 했는데 너무 물리적으로 접근한 것 같다. 함수 안에서 값들이 어떻게 돌아가는지 파악하면서 코드를 짜야겠다. 

참고 : [https://data-jj.tistory.com/34](https://data-jj.tistory.com/34)
