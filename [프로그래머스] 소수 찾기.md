
# [프로그래머스] 소수 찾기

### 문제

1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하는 함수, solution을 만들어 보세요.

* n은 2이상 1000000이하의 자연수

</br>

### 문제해결과정

소수 찾기는 많이 풀어본 문제라서 금방 통과할 줄 알았는데 시간초과에서 막혀버렸다.

아마도 이중 for문 때문인것 같다.

</br>

**시간 초과(1)**

```python
def solution(n):
    answer = 0
    for x in range(1,n+1):
        cnt = 0
        for i in range(1,x+1):
            if x%i==0:
                cnt+=1
        if cnt == 2:
            answer+=1
    return answer
```

</br>

시간을 조금 아끼기 위해 while문을 사용해서 조건에 맞으면 바로 반복을 중단하고 빠져 나올 수 있도록 짰다. 하지만 이중 반복이라는 점에서 시간을 크게 단축시키지 못했다.

**시간 초과(2)**

```python
def solution(n):
    num = list(range(2,n+1))
    prm = []
    while len(num)>0:
        prm.append()
        for j in num:
            if j % prm[-1] == 0:
                num.remove(j)
    return len(prm)
```

</br>

소수를 찾는 방법이 연산을 사용하는 것 말고도 에라토스테네스의 체라는 알고리즘이 있었다.

</br>

**에라토스테네스의 체**

- 다수의 자연수에 대하여 소수 여부를 판별할 때 사용하는 대표적인 알고리즘
- 에라토스테네스의 체는 N보다 작거나 같은 모든 소수를 찾을 때 사용할 수 있다.
- 에라토스테네스의 체 알고리즘 동작 과정
  1. 2부터 𝑁까지의 모든 자연수를 나열한다
  2. 남은 수 중에서 아직 처리하지 않은 가장 작은 수 𝑖를 찾는다
  3. 남은 수 중에서 i의 배수를 모두 제거한다(𝑖는 제거하지 않는다)
  4. 더 이상 반복할 수 없을 때까지 2번과 3번의 과정을 반복한다
  

```python
def solution(n):
   #n의 개수만큼 true 배열
    answer = 0
    prime = [True]*(n+1) #인덱스 : 0~n
    m=int(n**0.5)
    for i in range(2,m+1):
       if prime[i] == True:
           for j in range(i+i,n+1,i): #i 이후 i의 배수는
               prime[j] = False # 소수에서 제거
    print(prime)
    for i in range(2,n+1):
        if prime[i]:
            answer +=1
    return answer
```

우선 prime이라는 배열에 n까지의 수가 모두 소수라고 가정하여 True를 넣어주었다. 이때 주의할 점은 n개로 배열을 만들면 0부터 n-1개의 수만 사용할 수 있으므로 n+1개로 만들어주어야 한다.

m은 배수를 확인하는 범위를 담아두었다. 1부터 n까지 각 수의 배수를 확인할 때 전체를 확인할 필요 없이 n의 제곱근까지 확인하면 된다. n의 제곱근은 0.5를 제곱한 것과 같다. 이 값은 float값이므로 마지막에 int로 형변환을 해주어야 한다.

n은 2부터 주어지므로 범위는 2부터 m까지의 배수를 모두 제거해주면 된다. (제거 => False)

문제를 풀 때 막혔던 부분이 i의 배수를 소수에서 제거하는데 그 대신 i는 제거되지 않도록 하는 것이었다.  위 코드에서는 제거할 때 범위를 i+i로 해주어서 i 이후부터 탐색하도록 했다. 게다가 i의 배수를 판별할 때 나머지 연산이 아니라 range의 step을 이용한 점이 인상깊었다. step이 있는 줄 알았지만 평소에 쓸 일이 없어서 떠올리지 못했다. 이렇게 step을 i로 지정해주면 i의 배수는 모두 제거될 수 있다.

제거를 마치고 소수의 개수를 세는 일만 남았다.

True값 만을 출력하면 되므로 if문을 사용했다. 이때 0과 1은 소수에 포함되지 않으므로 범위를 2부터 지정해주어야 한다. 2부터 마지막까지 True값일 때마다 answer를 +1 해주고 마지막에 answer를 리턴해주면 n이하의 소수들의 개수가 반환된다.

</br>

### 요점 정리

* 소수 판별 
  * 약수의 개수가 2인 것을 찾는 방법
  * 에라토스테네스의 체
* range(시작범위:마지막 범위+1:스텝)





