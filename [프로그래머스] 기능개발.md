# [프로그래머스] 기능개발

### 문제

프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.

또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.

먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.

##### 제한 사항

- 작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.
- 작업 진도는 100 미만의 자연수입니다.
- 작업 속도는 100 이하의 자연수입니다.
- 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.

</br>

### 문제해결과정

이번 문제는 스스로 해결하지 못했다.

문제를 해결하는 알고리즘까지는 생각할 수 있었지만 그것을 코드로 구현하는 과정에서 막혔다. 여러 방법을 시도했지만 앞 뒤 날짜를 확인하여 카운트를 하던, 그 값을 지우던 해서 

**방법1**

1. 각 기능별로 완성되는 날을 계산해서 day 리스트 생성(공통) 
   * math의 ceil을 이용하여 올림계산
2. day를 가지고 각 날짜들을 비교 
   * 다음에 더 큰 수가 있으면 바로 answer에 넣음 
   * 현재 수가 다음 수보다 더 크면 다음 수는 현재 수와 같은 값으로 지정
3. answer를 set으로 만들어서 리턴

> 실패 원인 : set( )

set() 을 씌우고 출력하니 순서가 뒤죽박죽이 되어서 반환되었다.

</br>

**방법2**

1. 공통
2. 방법1의 2
3. answer의 각 숫자 개수를 count()를 사용해서 반환

>  실패 원인 : set( )

이 방법 또한 set( ) 때문에 망했다.

각 숫자를 세기 위해 for문을 사용할 때 iterable을 set(day)로 했는데, 이때 day의 값들이 순서가 바뀌면서

출력했을 때 answer의 값도 순서가 엉망이었다.

이 문제는 순서가 있는 문제이므로 set과 같은 자료구조는 사용할 수 없다는 것을 깨달았다.

</br>

**방법3**

1. 공통
2. day를 반전시켜 stack을 생성
3. day값을 비교해서 현재보다 큰 값이 나오기 전까지 pop을 하고, pop의 카운트를 세서 answer에 넣음

> 실패 원인 : 중복 while문

중복 while문을 사용한다는 부담때문에 끝까지 코드를 짜지 못했다. 

* 외부 while문 : 카운트를 리셋하고 다음 day로 이동
* 내부 while문 : i가 다음 값보다 큰 수가 나오기까지 카운트하면서 다음 값으로 이동

이외에 여러 시도 끝에 더 이상은 시간을 허비할 수 없다고 느껴 다른 사람들의 풀이를 보았다.

</br>

그중 가장 내가 풀고자 했던 방식으로 구현한 코드를 참고했다.

```python
from math import ceil

def solution(progresses, speeds):
    count=1
    day = list(map(lambda x: (ceil((100 - progresses[x]) / speeds[x])), range(len(progresses))))
    answer = []

    for i in range(len(day)):
        try: #인덱스 에러가 날 수 있는 코드
            if day[i] < day[i + 1]: #다음 day값보다 현재가 작으면
                    answer.append(count) #이때까지의 count를 answer에 저장
                    count = 1 #카운트 초기화
            else: #다음 day값이 현재보다 크거나 같으면(바로 배포할 수 없는 경우)
                day[i + 1] = day[i] #다음 값을 현재 값으로 변환
                count += 1 #카운트 셈
        except IndexError: #인덱스 에러가 나면
            answer.append(count) #이제까지 카운트한 것을 넣음

    return answer
```

</br>

처음 위 코드를 접했을 때 예외처리 구문을 보고 기피감이 생겨 다른 코드를 찾아보았지만 예외처리를 조금 검색해보니 그리 어려운 구문이 아니었다. 

try문에는 기존에 코드를 적듯이 적으면 된다. 단, 이 안에 코드를 넣는 이유는 에러가 발생할 수 있기 때문이다.

except문에는 try에 적은 코드에서 어떤 에러가 발생하는지 적어주고 그 밑에 에러 발생 시 어떠한 동작을 할 지 적어주면 된다.

위 코드 같은 경우 else문에서 에러가 발생한다. 같이 배포해야하는 기능을 카운트하는 과정에서 day[i+1]를 사용했기 때문에 index 에러가 난다.

이것을 방지하기 위해 범위를 바꿔준다면 모든 요소를 세어줄 수 없다.

따라서 카운트를 하다가 인덱스가 넘어가는 지점에서 지금까지 센 카운트를 그대로 answer에 넣어주면

모든 요소를 카운트할 수 있게 된다.

</br>

### 코드 개선

```python
day=[]
for i,j in zip(progresses, speeds):
    day.append(math.ceil((100-i)/j))
```

day를 만들 때 위와 같이 for문을 이용해서 구현했는데, 다음과 같이 람다로 빠르게 구현할 수 있다.

```python
day = list(map(lambda x: (ceil((100 - progresses[x]) / speeds[x])), range(len(progresses))))
```

람다를 다루긴 했지만 아직 낯설어서 그런지 잘 사용하지 않게 되는데 효율성을 따져봐도 람다가 훨씬 빠르고

코드가 간결해지기 때문에 가능한 많이 접해봐야겠다.

</br>

### 요약정리

* math.ceil( ) : 올림 계산

* 예외처리

  ```python
  try:
      '''
      예외가 발생할 수 있는 코드
      '''
  except: #예외 종류
      '''
      예외가 발생했을 때 동작시키 코드
      '''
  ```

  