# [프로그래머스] 짝지어 제거하기

### 문제

짝지어 제거하기는, 알파벳 소문자로 이루어진 문자열을 가지고 시작합니다. 먼저 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾습니다. 그다음, 그 둘을 제거한 뒤, 앞뒤로 문자열을 이어 붙입니다. 이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료됩니다. 문자열 S가 주어졌을 때, 짝지어 제거하기를 성공적으로 수행할 수 있는지 반환하는 함수를 완성해 주세요. 성공적으로 수행할 수 있으면 1을, 아닐 경우 0을 리턴해주면 됩니다.

예를 들어, 문자열 S = `baabaa` 라면

b *aa* baa → *bb* aa → *aa* →

의 순서로 문자열을 모두 제거할 수 있으므로 1을 반환합니다.

##### 제한사항

- 문자열의 길이 : 1,000,000이하의 자연수
- 문자열은 모두 소문자로 이루어져 있습니다.

</br>

### 문제해결과정

우선 문제를 순서에 맞게 정리해보았다.

* 같은 문자 2개가 있는 곳을 찾음
* 그 둘을 제거함
* 나머지 문자열을 연결함
* 위 과정을 반복해서 문자열이 모두 제거되면 1, 남아있으면 0을 반환



처음에는 re.sub()을 써야하나 했지만 단순히 두 개의 문자열이 나올 때마다 제거하는 것이므로 굳이 사용하지 않아도 되겠다고 생각했다. 

for문을 통해 앞 뒤 문자열을 비교하고 같으면 두개를 모두 지우고 반복하도록 하면 되겠다 싶어서 다음과 같이 작성했다.

```python
def solution(n):
    for i in range(len(n)+1):
        try:
            if n[i] == n[i+1]:
                n = n.replace(n[i]+n[i+1],'')
                return solution(n)
        except IndexError:
            return int(len(n) == 0)
```

문자열 제거는 replace를 이용했는데, 이때 같은 문자열을 둘 다 지워야 한다.  

문자열을 지우고 나서 다시 해당 함수를 호출해 같은 동작을 반복하도록 했다.

반복할수록 문자열의 길이가 짧아져서 indexerror가 날 수 밖에 없다. 이 에러나 나면 해당 문자열의 순환이 끝났다는 의미이므로 그때의 문자열 길이 여부에 따라 1또는 0을 반환하도록 했다.

하지만 위 코드는 테스트 케이스 몇개에서 실패했고, 효율성도 통과하지 못했다.

아직 반례는 찾지 못했지만 효율성에서 통과를 못했으니 다른 방법으로 짜야하는 것은 당연했다.

질문 목록을 보다가 스택을 사용하라는 글을 보고 어떤 식으로 스택을 적용하면 좋을 지 정리해보았다.

* 스택에 비어있으면 push하고 다음 문자로 넘어감
* 스택이 비어있지 않으면
  * 현재 문자와 비교
    * 스택의 top과 현재 문자가 같으면 스택에서 pop, 다르면 현재 문자를 push
* 마지막에 스택의 크기가 0이면 1, 0이 아니면 0 반환

```python
def solution(n):
    stack=[]
    for i in range(len(n)):
        if len(stack) == 0:
            stack.append(n[i])
        else:
            if stack[-1]==n[i]:
                stack.pop()
            else:
                stack.append(n[i])

    return int(len(stack) == 0)
```



</br>

### 요약정리

* boolean => int 형변환 가능
  *  True = 1, False = 0으로 변환 가능