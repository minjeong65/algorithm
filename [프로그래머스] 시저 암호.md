# [프로그래머스] 시저 암호

### 문제

어떤 문장의 각 알파벳을 일정한 거리만큼 밀어서 다른 알파벳으로 바꾸는 암호화 방식을 시저 암호라고 합니다. 예를 들어 "AB"는 1만큼 밀면 "BC"가 되고, 3만큼 밀면 "DE"가 됩니다. "z"는 1만큼 밀면 "a"가 됩니다. 문자열 s와 거리 n을 입력받아 s를 n만큼 민 암호문을 만드는 함수, solution을 완성해 보세요.

##### 제한 조건

- 공백은 아무리 밀어도 공백입니다.
- s는 알파벳 소문자, 대문자, 공백으로만 이루어져 있습니다.
- s의 길이는 8000이하입니다.
- n은 1 이상, 25이하인 자연수입니다.

</br>

### 문제해결과정

st라는 새로운 변수를 만들어 해당 문자의 아스키코드에 옮긴 거리를 더해주었다.

그리고 우선적으로 공백을 처리해 주었다. 공백은 밀어도 공백이라고 했으므로 옮기지 않는다고 여겨 n을 도로 빼주었다.(공백의 아스키코드 : 32)

그리고 나서 소문자일 때와 대문자일 때를 처리해주었는데, 각각 옮겼을 때 범위를 벗어나지 않는 경우를 한번에 처리해주었다. 이때는 st는 그대로이다.

끝에 있는 숫자들이 앞 문자로 밀리는 경우를 소문자일 때와 대문자일 때로 나눠서 범위를 지정했다.

각 문자별로 이동한 자리의 아스키코드를 연산한 뒤 이것을 문자로 변환해주는 chr()를 이용해서 answer에 더해주었다.

```python
def solution(s,n):
    answer = ''
    for i in s:
        st = ord(i) + n
        if ord(i) == 32:
            st -= n #공백은 안밈
        #밀었을 때 범위를 안넘어가는 경우
        elif 65<= ord(i) <=90 and 65<= st <=90 or 97<= ord(i) <=122 and 97<= st <=122: 
            st=st
		#범위 밖으로 밀려나 앞으로 돌아가는 경우
        else:
            if 90 < st <= 90+n: # 대문자가 앞으로 돌아가는 경우
                st = 65 + ( st - 91 )
            elif 122 < st <= 122 + n: # 소문자가 앞으로 돌아가는 경우
                st = 97 + ( st - 123 )
        answer += chr(st)
    return answer
```

</br>

### 코드개선

위 코드의 if문을 보면 범위가 깔끔하게 떨어지지 않아서 좀 찝찝한 구석이 있었는데, 다른 풀이를 참고하여 다음과 같이 개선했다.

```python
def solution(s,n):
    answer = ''
    for i in s:
        if ord(i) == 32:
            i=i #공백은 안밈
        if i.isupper(): #대문자인 경우
            i = chr((ord(i) - ord('A') + n) % 26 + ord('A'))
        elif i.islower(): #소문자인 경우
            i = chr((ord(i) - ord('a') + n) % 26 + ord('a'))
        answer += i
    return answer
```

st라는 새로운 변수를 만들지 않고 값을 그때마다 바꿔주도록 i에 값을 업데이트하는 식으로 구현했다.

공백문자를 동일하게 따로 처리해주었다.

그 이후부터 개선된 부분이다.

우선 크게 소문자와 대문자인 경우로 나누었고, 이때 is.upper(), is.lower()함수를 사용했다.

소문자인 경우 해당 문자의 아스키코드에서 시작점인 a의 값을 빼주고 옮긴 거리인 n을 더했다. 그리고 이 값을 26으로 나누었는데, 26는 소문자의 개수이다. 26으로 나누게 되면 나머지가 26이하의 수가 되어 a부터 z까지의 범위를 순환할 수 있다. 여기까지 계산을 하면 일정부분은 z까지 옮기고 범위가 벗어나서  a부터 옮겨야하는 거리가 남게 된다. 여기에 시작점인 a의 값을 더해서 결과적으로 이동한 알파벳의 아스키코드를 만들어 낸다. 

대문자도 동일하게 구현하면 된다.

이렇게 계산된 값을 chr()를 사용해서 문자로 바꾸고 answer에 더해준다. 

</br>

### 요약정리

* 특정 범위를 순환해서 이동하는 경우 **나머지 연산**을 활용해서 구현할 수 있는 점을 알게 되었다.
* is.upper( ) : 대문자인지 확인 / is.lower() : 소문자인지 확인
* ord(문자) : 해당 문자의 아스키코드를 반환
* chr(아스키코드) : 아스키코드에 해당하는 문자를 반환 

