# [백준 11047] 동전 0

### 문제

준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.

동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.

**입력**

첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)

둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)

**출력**

첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.

</br>

### 문제해결과정

최소한의 동전을 사용해야 하므로 사용할 수 있는 동전 중 가장 큰 단위의 동전을 최대한 이용해야 한다.

그러기 위해서 값이 들어있는 k의 범위를 먼저 찾는다. 리스트 a에 각 동전 단위를 오름차순으로 담아두었다. 

i를 늘려가며 k값이 포함되어 있는 범위를 찾은 뒤 시작범위로 k를 나누어 몫은 카운트하고, 나머지는 k로 해서 k가 0이 될 때까지 반복하도록 했다. 

하지만 이렇게만 구현하면 런타임 에러가 난다. 그 원인을 찾기 위해 아무 숫자나 넣어봤는데, 원인을 바로 찾을 수 있었다.

에러가 나는 경우는 k가 동전의 최대 단위보다 더 큰 경우이다. 이때는 맞는 값을 찾을 수 없기 때문에 무한반복이 되며, i가 무한히 늘어나면서 a에 대한 인덱스 에러도 발생한다.

그러므로 k가 단위의 최댓값보다 많은 경우를 따로 처리해주어야 한다.

이 경우 최대 크기로 나누어서 몫은 카운트에 더하고 나머지는 k에 넣어준다.

그리고나서 while문을 실행하게 된다.

```python
n,k = map(int, input().split())
a=[]
cnt = 0

# 동전 단위
for i in range(n):
    a.append(int(input()))

#k가 최대 단위보다 큰 경우
i=0
if k > a[-1]:
    cnt += k//a[-1]
    k = k % a[-1]

while k != 0:
    if a[i] <= k < a[i+1]:
        cnt += k//a[i]
        k = k % a[i]
        i=0
    else:
        i+=1
        
print(cnt)
```

</br>

### 코드개선

다른 코드를 보니 굳이 범위를 찾지 않고 가장 큰 단위로 순서대로 나누어주면서 몫은 카운트로 누적하고, 나머지는 k로 바꿔주는 과정을 반복하면 되었다. 시간도 덜 잡아먹고 훨씬 간결하다.

```python
n,k = map(int, input().split())
a=[]
cnt = 0

for i in range(n):
    a.append(int(input()))

while k > 0 :
    coin = a.pop() #큰 값부터 나누어야 하므로 pop()사용
    cnt += k // coin
    k %= coin

print(cnt)
```

