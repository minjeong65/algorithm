# [백준 2775] 부녀회장이 될테야 

### 문제

평소 반상회에 참석하는 것을 좋아하는 주희는 이번 기회에 부녀회장이 되고 싶어 각 층의 사람들을 불러 모아 반상회를 주최하려고 한다.

이 아파트에 거주를 하려면 조건이 있는데, “a층의 b호에 살려면 자신의 아래(a-1)층의 1호부터 b호까지 사람들의 수의 합만큼 사람들을 데려와 살아야 한다” 는 계약 조항을 꼭 지키고 들어와야 한다.

아파트에 비어있는 집은 없고 모든 거주민들이 이 계약 조건을 지키고 왔다고 가정했을 때, 주어지는 양의 정수 k와 n에 대해 k층에 n호에는 몇 명이 살고 있는지 출력하라. 단, 아파트에는 0층부터 있고 각층에는 1호부터 있으며, 0층의 i호에는 i명이 산다.

**입력**

첫 번째 줄에 Test case의 수 T가 주어진다. 그리고 각각의 케이스마다 입력으로 첫 번째 줄에 정수 k, 두 번째 줄에 정수 n이 주어진다

**출력**

각각의 Test case에 대해서 해당 집에 거주민 수를 출력하라.

</br>

### 문제해결과정

직접 거주민 수를 적으면서 하다보니 규칙은 대충 알 것 같았는데, 코드로 구현하기까지 매우 오랜 시간이 걸렸다.

알게 된 규칙은 a층 b호의 인원 = (a-1)층 b호의 인원 + a층 (b-1)호의 인원과 같다는 것이다.

이것을 재귀로 구현해볼까 했지만 0층까지 갔다가 다시 계산하러 거슬러 올라와야 하기 때문에 시간초과의 우려가 있었다.

처음부터 다시 시작해서, 문제에 나와있는대로 구현해보기로 했다.

이전 층수의 1부터 b호까지의 인원을 더하도록 하는 방법이 뭐가 있을까 하다가 한 층을 배열로 만들어 호수 별로 더해진 값을 다른 배열에 넣은 뒤 처음 만든 배열에 값을 저장하고, 나중에 만든 배열은 초기화하는 식으로 계속해서 사용하면 될 것 같아서 다음과 같이 구현했다.

m과 n은 a(층)와 b(호수)를 의미한다. 

처음 li라는 리스트에 1부터 n까지를 셋팅해놓고, st라는 빈 리스트를 만들었다.

구현할 내용을 정리하자면

1. 0층에 해당하는 리스트 생성 및 빈 리스트 생성
2. b까지의 합을 누적하여 su에 담고 빈 리스트에 저장
3. 새로 만든 리스트 값을 처음 만든 리스트에 저장하고 새로 만든 리스트를 빈 리스트로 초기화
4. 이와 같은 과정을 층수(m)만큼 반복

</br>

```python
N = int(input())

for _ in range(N):
    
    m = int(input()) #층
    n = int(input()) #호수

    li = [x for x in range(n+1)] #0부터 n까지 배열 생성

    st=[]
    for a in range(m): #층수 만큼 반복
        for i in range(1,n+2):  #호수 만큼 반복
            su=0
            for j in range(i):
                su += li[j]
                print(su, li[j])
            print()
            st.append(su)

        print(li)
        print(st)

        li = st
        st = []
        

    print(li[n])
```

</br>

호실은 0을 제외해야하기 때문에 st에 값을 다 넣은 다음에 슬라이싱을 해서 0을 모두 지워준다. 또한 0을 만들기 위해 반복한 만큼(1) 반복을 더 해주어야하기 때문에 호수만큼 반복할 때 n+2까지 범위를 적어주어야 한다.

출력할 때는 가장 최근 값을 담은 li에서 호실을 인덱스로 담으면 원하는 값을 출력한다.

</br>

### 코드개선

인덱스를 사용한 계산은 항상 머리가 지끈거린다.

이번 문제도 비슷한 맥락인 것 같은데, 너무 복잡하게 풀어나간 것 같다.

다음 코드는 허무할 정도로 간단한 코드인데 슬라이싱 같은 부수적인 작업이 필요없는 깔끔한 코드이다.

```python
N = int(input())

for _ in range(N):

    k = int(input())
    n = int(input())

    people = [ i for i in range(1, n+1)]
    for __ in range(k):

        for j in range(1,n):
            people[j] += people[j-1]

    print(people[-1])
```

우선 n까지의 리스트를 생성하는 것까지는 동일하다.

리스트를 새로 생성할 것 없이 생성되어 있는 리스트를 사용해서 새로운 값을 씌울 수 있다는 것을 배웠다.

참조하는 리스트가 변형되면 계산이 잘못될 것 같아서 새로 생성했는데, 덧셈이 되는 과정을 보니 상관이 없다는 것을 알게 되었다.

people[j]는 현재 참조하고 있는 값인데, 자신과 이전 값을 더한 값으로 다시 값을 부여하면 이전 결과에 누적을 하게 된다. 이전 값도 같은 방식으로 더 이전의 값을 누적한 것이므로 누적계산이 된다.

출력할 때는 마지막 요소를 출력하도록 -1로 인덱싱을 해주었다.

</br>

코드만 보면 그리 어려운 문제는 아닌 것 같은데, 아직까지는 유연한 사고가 잘 되지 않는 것 같다.

문제는 어떻게든 푸는 것도 중요하지만, 문제를 풀고 나서 다른 풀이를 보며 더 실용적인 코딩을 배우는 과정이 지금 매우 중요한 것 같다.

다양한 코드를 보며 배우고 절대 잊지 말아야겠다.

</br>

### 요약정리

* 1부터 n까지의 누적 계산

  ```
  for j in range(1,n):
          people[j] += people[j-1]
  ```

