# [이코테] 음료수 얼려 먹기

### 문제

DFS 를 활용해야 하는 문제이다. NXM 크기의 얼음틀이 있는데, 음료수를 얼음틀로 얼려서 아이스크림을 만들어 먹으려고 한다. 0은 구멍이 뚫려있는 상태고, 1은 칸막이다. 구멍이 상,하,좌,우로 붙어있으면 연결되어있다고 볼 때, 만들어지는 아이스크림의 개수를 구하는 문제이다. 

### 문제해결과정

오늘 DFS 알고리즘을 처음 배우면서 접한 문제이기 때문에 접근 방식까지만 생각해보고 정답 코드를 이해하는 것에 초점을 맞췄다. 

일단 0으로 둘러싸인 부분에 DFS를 실행시키고 또 다른 0을 찾아서 그 구역에 DFS를 실행하면 되지 않을까하고 생각했었다. 이렇게 한 뒤 각 영역에서의 DFS가 실행되면 카운트를 세서 출력하면 될 것 같다고 생각했다.

접근방식은 맞았다. 하지만 막상 정답 코드를 보니 이해가 가지 않아 한참을 들여다 봤다.

스택 하나하나 들어가고 나가는 것을 생각하려다 보니 너무 복잡해진 것 같다.

일단 코드를 보자.

```python
def dfs(x,y):
    #주어진 범위를 벗어나면 종료
    if x<=-1 or x>=n or y<=-1 or y>=m:
        return False
    #DFS
    if graph[x][y] == 0: #방문안한 노드라면
        graph[x][y] = 1 #방문처리
        #상하좌우 위치들도 모두 재귀적으로 호출
        dfs(x-1,y)  #상
        dfs(x+1, y) #하
        dfs(x,y-1)  #좌
        dfs(x,y+1)  #우
        return True #DFS 실행한 후 True 리턴
    return False
       
n,m = map(int, input().split()) #얼음판 크기
#얼음판 생성
graph = []
for i in range(n):
    graph.append(list(map(int, input())))
#모든 노드에 음료수 채우기
result = 0
for i in range(n):
    for j in range(m):
        #현재 위치에서 DFS 실행
        if dfs(i,j) == True: #DFS가 실행되었으면
            result += 1
print(result)
```

DFS는 함수로 따로 구현해두었다.

n,m의 입력을 받고 이중for문을 이용해서 모든 요소에 DFS를 실행시킨다.

DFS함수를 보면,

주어진 범위를 벗어나면 종료하도록 종료조건을 걸어두고 해당 요소가 0인지 판별하여 0이면 방문처리(1)를 하고 상,하,좌,우로 DFS를 실행한다. 인덱스 관점에서 봤을 때 상, 좌를 볼 때 이전 인덱스를 탐색하기 때문에 위와 같은 범위가 설정된 것이다. 

한번의 DFS가 실행되면 True값을 리턴한다.

이것을 메인함수에서 받아서 DFS가 실행된 경우 그 영역이 음료수로 채워졌다는 뜻이므로 result를 하나 늘려준다.

동작을 살펴보면

처음 노드 탐색 시 (0,0)에서 dfs함수를 호출한다. 해당 값이 0이므로 1로 바꿔주고 dfs를 실행한다.

(0,0) => (1,0) => (1,1) => (0,1) => (1,2)  순으로 1로 채워진다.

한번의 dfs가 실행되었으므로 카운트를 늘린다.

한 영역이 채워지고 나서 다음 노드를 살피며 0인 곳을 찾는다. => (0,4)

(0,4)에서 dfs를 호출하고 실행한 결과 (0,4) 만 1로 채워지게 된다.

카운트 + 1

또다시 0을 탐색하며 (3,0)에서 dfs를 탐색한다.

1이 채워지는 순서는 (3,0) => (3,1) => (3,2) => (3,3) => (3,4) 이다.

카운트 +1

결과적으로 3개의 아이스크림이 만들어지는 것을 알 수 있다.



### 요점정리

DFS : 깊이우선탐색

* 한 노드에 대해 가장 깊이 들어갔다가 더 이상 길이 없으면 다음 노드를 탐색한다.

* DFS 구현 예시

```python
def dfs(graph,v,visited):
    #현재 노드를 방문 처리
    visited[v] = True
    print(v, end='')
    for i in graph[v]:
        if not visited[i]:#방문되지 않은 노드라면
            dfs(graph, i, visited) #방문

graph = [ #첫번째 인덱스가 노드번호가 됨, 각 리스트에 자신의 이웃노드를 넣음
    [],      #인덱스 0의 내용은 비워둠 
    [2,3,8], #1의 이웃노드
    [1,7],   #2의 이웃노드
    [1,4,5], #3의 이웃노드
    [3,5],   #4의 이웃노드
    [3,4],   #5의 이웃노드
    [7],     #6의 이웃노드
    [2,6,8], #7의 이웃노드
    [1,7]    #8의 이웃노드
]

visited = [False] * 9 #아직 방문하지 않은 것으로 초기화

dfs(graph, 1, visited)
```





