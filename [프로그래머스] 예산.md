# [프로그래머스] 예산

### 문제

S사에서는 각 부서에 필요한 물품을 지원해 주기 위해 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다. 그러나, 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다. 그래서 최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다.

물품을 구매해 줄 때는 각 부서가 신청한 금액만큼을 모두 지원해 줘야 합니다. 예를 들어 1,000원을 신청한 부서에는 정확히 1,000원을 지원해야 하며, 1,000원보다 적은 금액을 지원해 줄 수는 없습니다.

부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때, 최대 몇 개의 부서에 물품을 지원할 수 있는지 return 하도록 solution 함수를 완성해주세요.

* d는 부서별로 신청한 금액이 들어있는 배열이며, 길이(전체 부서의 개수)는 1 이상 100 이하입니다.
* d의 각 원소는 부서별로 신청한 금액을 나타내며, 부서별 신청 금액은 1 이상 100,000 이하의 자연수입니다.
* budget은 예산을 나타내며, 1 이상 10,000,000 이하의 자연수입니다.

</br>

### 문제해결과정

가장 많은 부서를 지원하는 방법은 가장 적은 돈을 필요로 하는 부서부터 처리해주면 된다. 

우선 d를 오름차순으로 정렬한 뒤, 요소를 하나씩 더할 때마다 budget과 비교하여 그 합이 budget보다 작을때만 카운트해서 결과적으로 카운트 값을 반환하도록 만들었다.

</br>

**나의 풀이**

```python
def solution(d, budget):
    answer = 0 #count
    su = 0 #합계
    d=sorted(d)
    for i in d:
        su+=i 
        if su <= budget:
            answer += 1
    return answer
```

</br>

**다른 방법**

```python
def solution(d, budget):
    d.sort()
    while budget < sum(d):
        d.pop()
    return len(d)
```

위 코드는 처음부터 d의 합과 budget을 비교해서 큰 수부터 없애도록 해주었다. budget이 d의 합과 같거나 더 커지는 순간 반복을 멈추고 그때의 d에는 budget으로 처리할 수 있는 부서들이 담겨 있으므로 그 크기를 반환해준 것이다. 

</br>

### 요점정리

리스트 정렬

* list.sort()  : 원본 리스트를 변경, 복사본을 만들지 않기 때문에 속도가 더 빠름
* sorted(list) : 새로운 리스트를 반환(원본 리스트에 영향 없음)

