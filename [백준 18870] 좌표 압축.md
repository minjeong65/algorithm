# [백준 18870] 좌표 압축

### 문제

이 문제는 주어진 좌표를 문제에서 주어준 방식으로 변경하는 문제이다. 

좌표를 변경하는 방식은, 자기 자신보다 작은 수의 개수가 새로운 좌표가 된다.

따라서 가장 작은 수의 좌표는 0이 되고, 가장 큰 수의 좌표는 전체 개수-1이 된다.

이것은 인덱스와 범위가 같기 때문에 간단히 풀리는 문제였다.



### 문제해결과정

일단 제출한 코드는 다음과 같다.

```python
import sys

N=int(sys.stdin.readline()) #주어지는 좌표의 개수(1 ~ 1,000,000)

num=list(map(int,sys.stdin.readline().split())) #괄호 주의
s_num=sorted(list(set(num)))

for i in num: 
  print(s_num.index(i),end=' ') #시간 초과 발생
```



(5번째 줄에서 괄호 하나를 빼먹는 바람에 컴파일 에러를 여러번 겪었다. 주의해야겠다.)

일단 좌표를 리스트로 쭉 입력받고, set()와 sorted(), list()를 사용해서 새로 변경하는 데 필요한 수를 s_num에 담아놓았다.

입력 예제를 이용해서 설명하자면,

입력 좌표가 2 4 -10 4 -9 일 때 일단 이들을 set()에 넣어서 중복 숫자를 지워주고 sorted()를 적용하면 현재 남은 숫자는 -10 -9 2 4이다. 이것을 리스트화하여 담으면 각 요소의 인덱스는 그들의 새로운 좌표가 된다. (ex. -10의 새로운 좌표는 0)

어떤 숫자로 변경되어야 하는지 알았으니 출력할 차례이다.

새로운 좌표를 처음 입력한 좌표 순으로 출력해야하므로 처음 입력 좌표가 들어있는 리스트에서 i를 돌려서 해당 숫자의 새로운 좌표를 출력하도록 하였다.



일단 전체적인 문제풀이는 맞지만 채점을 해보면 pypy3로 돌려도 시간 초과가 나왔다. 그래서 구글링을 해보니 딕셔너리를 사용하여 시간초과를 해결하는 방법이 있었다.



시간초과는 마지막 for문에서 나는 것이었다. s_num.index()를 사용할 때의 시간 복잡도가 O(N)이어서 매번1,000,000번의 수행이 필요했던 것이다.



이를 딕셔너리로 바꾸면 다음과 같다.

```python
import sys

N=int(sys.stdin.readline()) #주어지는 좌표의 개수(1 ~ 1,000,000)

num=list(map(int,sys.stdin.readline().split())) #괄호 주의
s_num=sorted(list(set(num)))
dic={s_num[i]:i for i in range(len(s_num))}
for i in num:
    print(dic[i], end=' ')
```



i의 값과 일치하는 값을 찾아 인덱스를 뽑아내는 방식과 달리 딕셔너리는 시간복잡도 O(1)로 값을 바로 뽑을 수 있어서 시간초과를 해결할 수 있다.



### 요점정리

* 딕셔너리의 시간복잡도는 O(1)

