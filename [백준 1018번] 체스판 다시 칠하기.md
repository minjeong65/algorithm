이번 문제는 MxN크기의 보드에서 8x8만큼 잘라서 체스판을 만들려고 하는데 보드에 색이 제대로 칠해져있지 않아서 색을 다시 칠해야 하는상황에서 보드를 잘라 색을 칠할 때 가장 최소한의 수정개수를 출력하는 것이다.

내 풀이는 이러하다(틀린 코드임)
```
N,M=map(int, input().split()) #N:세로, M:가로
bd=[]
for i in range(N):
    bd.append(input())

result=[]
#틀린 방법
for i in range(N-7): 
    for j in range(M-7): 
        sum=0 #한 보드에 색칠해야 하는 수
        for k in range(8):
            c=abs(bd[k+i][j:j+8].count('B')-bd[k+i][j:j+8].count('W')) 
            sum+=int(c/2)
        result.append(sum)
print(min(result))
```
접근했던 방식은, 
B와 W가 한 행에서 같은 수만큼 나오므로 이 둘이 나오는 수를 count()로 받아서 서로 같지 않는 경우, (두 수의 차)/2를 하여 수정해야하는 횟수를 누적시켜 sum에 담았다. 하나의 체스판을 검토한 뒤 해당 sum을 result에 담아서 최종적으로 min()를 이용해 최소값을 출력했다. 

일단 이러한 접근 방식부터 틀렸다.
B와 W가 같으면 된다고 생각했던 이유는 주어진 입력에 나온 보드가 B와 W가 마구잡이로 섞여있는 것이 아니라 특정부분은 모두 B, 특정부분은 모두 W로 칠해져 있는 것이라 생각했다. 예제입력만 조건을 보고 잘못 판단한 것이다.

문제에서 체스판을 칠할 수 있는 방법은 두가지 밖에 없다고 나와있다. B로 시작하는 체스판과 W로 시작하는 체스판.
분명 이 부분이 힌트일 거라고 생각하고 접근해보았지만 위와 같이 잘못 판단해버리는 바람에 스타트를 잘못 끊은 것이다. 

일단 해답부터 보면
```
N,M=map(int, input().split())
bd=[] #보드
for i in range(N):
    bd.append(input())

result=[] #체스판을 만드는 모든 경우의 수의 수정횟수를 담음
#i,j는 시작점을 잡기 위한 반복
for i in range(N-7):
    for j in range(M-7):
        first_w=0 #w로 시작하는 경우 수정할 개수
        first_b=0 #B로 시작하는 경우 수정할 개수
        #i와 j를 범위로 사용해 최대크기를 8*8로 지정
        for k in range(i,i+8): #행 이동(i가 변하는 만큼에 8만큼만 이동)
            for l in range(j,j+8): #열 이동(j가 변하는 만큼에 8만큼만 이동)
                if (k+l)%2: 
                    if bd[k][l] !='W': #인덱스합이 짝수인데 W가 아니라면
                        first_w=first_w+1 #W로 시작하는 경우에는 인덱스합이 짝수일 때 W여야 하므로 고쳐야 함
                    else:     #인덱스합이 짝수인데 W라면
                        first_b=first_b+1 #B로 시작하는 경우에는 인덱스합이 짝수일 때 B여야 하므로 고쳐야 함
                else: 
                    if bd[k][l] !='B': #인덱스 합이 홀수인데 B가 아니라면
                        first_w=first_w+1 #W로 시작하는 경우에는 인덱스합이 홀수일 때 B여야 하므로 고쳐야 함
                    else:  #인덱스 합이 홀수인데 B라면
                        first_b=first_b+1 #B로 시작하는 경우에는 인덱스합이 홀수일 때 W여야 하므로 고쳐야 함

        result.append(first_w)
        result.append(first_b)

print(min(result))
```

이 문제는 B로 시작할 때와 W로 시작할 때를 따로 나눠서 경우의 수를 구해야한다.

이부분을 구현해내는 것이 핵심이라고 할 수 있다.

아래 블로그를 통해 그 규칙을 알게 되었다.

B와 W를 번갈아서 색을 입힌다고 할 때, 행과 열의 인덱스 합이 짝수인 경우, 그리고 홀수인 경우 각각 일정한 색을 가지고 있다. 

따라서 인덱스 합이 짝수인 경우와 홀수인 경우로 크게 나누었고,
그 안에서 시작점의 색에 따른 수정횟수를 계산하였다.

처음에 if문부터 너무 이해가 안돼서 한참을 고민했다.

뒤늦게 first_w와 first_b가 각각 W를 시작으로 할 때의 수정횟수, B를 시작으로 할 때의 수정횟수라는 것을 깨달았다.

코드에도 적어놨지만 좀 더 유연하게 설명하자면,
인덱스 값이 짝수라면, 그리고 이때 W가 아니라면
W로 시작하는 경우를 셀 때는 이것을 W로 고쳐주어야 하므로 first_w+=1라고 적은 것이고, 반대로 짝수면서, W인 경우에는 B를 시작으로 하는 경우를 셀 때, 이것을 B로 바꿔주어야 하므로 first_b+=1라고 적은 것이다.

마찬가지로 홀수이고, B가 아니라면
W로 시작하는 경우에는 B로 바꿔주어야 한다.
또한, 홀수이고, B가 맞을 때는 B로 시작하는 경우 이것을 W로 바꾸어야 한다.

사실 for문의 범위도 정말 많이 헷갈렸지만, 그림을 그리고, 수를 대입하면서 보니까 금방 이해할 수 있었다. 

나중에 다시 볼 때 부디 잊지 말기를...

이해하는데 너무 오래 걸렸다..

이번 문제를 풀면서(해답을 보면서) 느낀 것은 주어진 입출력에 너무 의존하지 않고 주어진 조건을 잘 파악하여 어떤 입력이 들어와도 알맞은 출력이 나올 수 있도록 풀어나가야겠다고 생각했다.

참고:https://god-gil.tistory.com/62
